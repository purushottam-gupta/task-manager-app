//CRUD - Create Read Update Delete
//in mongodb we have unique id for every document whose changing pattern is differnt than other database where in every docs id pattern is automatic incremention method which arises the case of colision of docs of same id but this problem gets solve in mongodbas here id gets generated by some algorithim and allows us to tranfer as many data as we want without getting into any problem. 
// const mongodb = require('mongodb');
// const MongoClient = mongodb.MongoClient
// const ObjectID = mongodb.ObjectID
const { MongoClient, ObjectID } = require('mongodb') //shorthand for above 3 lines

const connectURL = 'mongodb://127.0.0.1:27017'
const databaseName = 'task-manager'

//Creating object id and manipulating
// const id = new ObjectID()
// console.log(id)
// console.log(id.getTimestamp())//returns the time when that particular id was created
// console.log(id.id.length)//buffer value (binary value) of id with length 12
// console.log(id.toHexString().length)//string value of id with length 24

MongoClient.connect(connectURL, { useNewUrlParser: 'true', useUnifiedTopology: true }, (error, client) => {
    if (error) {
        return console.log("Unable to connect")
    }

    const db = client.db(databaseName)

    //Create -
    // db.collection('users').insertOne({
    //     name: 'Puru',
    //     age: "21"
    // },(error, result) => {
    //     if (error) {
    //         return console.log('unable to insert document')
    //     }
    //     console.log(result.ops)
    // })

    // db.collection('tasks').insertMany([
    //     {
    //         description: 'Meeting',
    //         completed: true
    //     },{
    //         description: 'Chatting',
    //         completed: true
    //     },{
    //         description: 'Talking',
    //         completed: false
    //     }
    // ],(error, result) => {
    //     if (error) {
    //         return console.log('unable to insert document')
    //     }
    //     console.log(result.ops)
    // })

    //Read -
    // db.collection('tasks').findOne({ _id: new ObjectID("5ff1dfc6e85ffc0c1cdfaa60") }, (error, task) => {
    //     if (error) {
    //         console.log('unable to fetch')
    //     }
    //     console.log(task)
    // })

    // db.collection('tasks').find({ completed: true }).toArray((error, task) => {
    //     console.log(task)
    // })//find doesnt hv callback fn as it returns value in cursor
    // db.collection('tasks').find({ completed: true }).count((error, count) => {
    //     console.log(count)
    // })

    //Update -
    // db.collection('user').updateOne({
    //    _id: new ObjectID("5ff0d520c8bcf42cc83c533f") 
    // }, {
    //     $inc: {
    //         age: 1
    //     }
    // }).then((result) => {
    //     console.log(result)
    // }).catch((error) => {
    //     console.log(error)
    // })

    // db.collection('tasks').updateMany({
    //     completed: true
    // }, {
    //     $set: {
    //         completed: false
    //     }
    // }).then((result) => {
    //     console.log(result)
    // }).catch((error) => {
    //     console.log(error)
    // })

    //Delete -
    // db.collection('tasks').deleteMany({
    //     completed: true
    // }).then((result) => {                  
    //     console.log(result)
    // }).catch((error) => {
    //     console.log(error)
    // })//(here we r using promise as when no callback fn is passed then it returns promise)

    db.collection('tasks').deleteOne({
        description: 'Meeting'
    }).then((result) => {
        console.log(result)
    }).catch((error) => {
        console.log(error)
    })


})